/*!
 * Copyright (c) 2021 by Contributors
 * \file pass.h
 * \brief Customized MNM passes
 */
#pragma once

#include "mnm/pass.h"

namespace mnm {
namespace pass {

/*!
 * \brief Eliminate the closure in returned value. Replace them with constant 1s.
 * \return The pass.
 */
Pass EliminateClosure();

/*!
 * \brief Wrap identity output values with mnm.op.copy
 * \return The pass.
 */
Pass WrapIdentity();

/*!
 * \brief Canonicalize parameters of the backward closure generated by AutoDiff.
 * \return The pass.
 */
Pass CanonicalizeParamsForRAZOR();

/*!
 * \brief Analyze the IR to get a mapping from output tuple indices to input
 * argument indices that share the same memory (inplace update).
 * \return The pass.
 */
Pass InplaceUpdateAnalysis();

/*!
 * \brief Mutate the IR to attach in-place update information according to the given alias map.
 * Note that we cannot simply mark may_share because the IR may be transformed to GNF and erase
 * the alias information. Thus, for now we only update the ops with "out" in their arguments.
 */
Pass InplaceUpdateByAlias(ir::Map<tvm::Integer, tvm::Integer> alias_map);

/*!
 * \brief This pass will be used to apply ZeRO1 optimization, which partitions the model states into
 * N ranks, and allgather all the partial values to update the weight. Note that this pass only does
 * the last step, which finds the IR patterns and replaces with allgather ops. The actual optimizer
 * states buffer partition is done as we create the optimizer.
 */
Pass PartitionOptimStatus();

}  // namespace pass
}  // namespace mnm
